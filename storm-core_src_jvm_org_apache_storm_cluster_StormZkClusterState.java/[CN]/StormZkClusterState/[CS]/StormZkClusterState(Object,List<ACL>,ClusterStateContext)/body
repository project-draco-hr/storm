{
  if (clusterState instanceof ClusterState) {
    solo=false;
    this.clusterState=(ClusterState)clusterState;
  }
 else {
    solo=true;
    this.clusterState=new DistributedClusterState((Map)clusterState,(Map)clusterState,acls,context);
  }
  assignmentInfoCallback=new ConcurrentHashMap<>();
  assignmentInfoWithVersionCallback=new ConcurrentHashMap<>();
  assignmentVersionCallback=new ConcurrentHashMap<>();
  supervisorsCallback=new AtomicReference<>();
  backPressureCallback=new ConcurrentHashMap<>();
  assignmentsCallback=new AtomicReference<>();
  stormBaseCallback=new ConcurrentHashMap<>();
  credentialsCallback=new ConcurrentHashMap<>();
  logConfigCallback=new ConcurrentHashMap<>();
  blobstoreCallback=new AtomicReference<>();
  stateId=this.clusterState.register(new Callback(){
    public <T>Object execute(    T... args){
      if (args == null) {
        LOG.warn("Input args is null");
        return null;
      }
 else       if (args.length < 2) {
        LOG.warn("Input args is invalid, args length:" + args.length);
        return null;
      }
      String path=(String)args[1];
      List<String> toks=Zookeeper.tokenizePath(path);
      int size=toks.size();
      if (size >= 1) {
        String params=null;
        String root=toks.get(0);
        IFn fn=null;
        if (root.equals(Cluster.ASSIGNMENTS_ROOT)) {
          if (size == 1) {
            issueCallback(assignmentsCallback);
          }
 else {
            issueMapCallback(assignmentInfoCallback,toks.get(1));
            issueMapCallback(assignmentVersionCallback,toks.get(1));
            issueMapCallback(assignmentInfoWithVersionCallback,toks.get(1));
          }
        }
 else         if (root.equals(Cluster.SUPERVISORS_ROOT)) {
          issueCallback(supervisorsCallback);
        }
 else         if (root.equals(Cluster.BLOBSTORE_ROOT)) {
          issueCallback(blobstoreCallback);
        }
 else         if (root.equals(Cluster.STORMS_ROOT) && size > 1) {
          issueMapCallback(stormBaseCallback,toks.get(1));
        }
 else         if (root.equals(Cluster.CREDENTIALS_ROOT) && size > 1) {
          issueMapCallback(credentialsCallback,toks.get(1));
        }
 else         if (root.equals(Cluster.LOGCONFIG_ROOT) && size > 1) {
          issueMapCallback(logConfigCallback,toks.get(1));
        }
 else         if (root.equals(Cluster.BACKPRESSURE_ROOT) && size > 1) {
          issueMapCallback(logConfigCallback,toks.get(1));
        }
 else {
          LOG.error("{} Unknown callback for subtree {}",new RuntimeException("Unknown callback for this path"),path);
          Runtime.getRuntime().exit(30);
        }
      }
      return null;
    }
  }
);
  String[] pathlist={Cluster.ASSIGNMENTS_SUBTREE,Cluster.STORMS_SUBTREE,Cluster.SUPERVISORS_SUBTREE,Cluster.WORKERBEATS_SUBTREE,Cluster.ERRORS_SUBTREE,Cluster.BLOBSTORE_SUBTREE,Cluster.NIMBUSES_SUBTREE,Cluster.LOGCONFIG_SUBTREE};
  for (  String path : pathlist) {
    this.clusterState.mkdirs(path,acls);
  }
}
