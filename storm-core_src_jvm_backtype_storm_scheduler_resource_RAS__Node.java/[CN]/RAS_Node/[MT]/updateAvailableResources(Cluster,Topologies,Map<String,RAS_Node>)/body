{
  if (cluster.getAssignments().size() > 0) {
    for (    Entry<String,SchedulerAssignment> entry : cluster.getAssignments().entrySet()) {
      Map<ExecutorDetails,WorkerSlot> executorToSlot=entry.getValue().getExecutorToSlot();
      Map<ExecutorDetails,Double> topoMemoryResourceList=topologies.getById(entry.getKey()).getTotalMemoryResourceList();
      if (topoMemoryResourceList == null || topoMemoryResourceList.size() == 0) {
        continue;
      }
      for (      Map.Entry<ExecutorDetails,WorkerSlot> execToSlot : executorToSlot.entrySet()) {
        WorkerSlot slot=execToSlot.getValue();
        ExecutorDetails exec=execToSlot.getKey();
        RAS_Node node=nodeIdToNode.get(slot.getNodeId());
        if (!node.isAlive()) {
          continue;
        }
        if (topoMemoryResourceList.containsKey(exec)) {
          node.consumeResourcesforTask(exec,topologies.getById(entry.getKey()));
        }
 else {
          LOG.warn("Resource Req not found...Scheduling Task{} with memory requirement as on heap - {} and off heap - {} and CPU requirement as {}",exec,Config.TOPOLOGY_COMPONENT_RESOURCES_ONHEAP_MEMORY_MB,Config.TOPOLOGY_COMPONENT_RESOURCES_OFFHEAP_MEMORY_MB,Config.TOPOLOGY_COMPONENT_CPU_PCORE_PERCENT);
          topologies.getById(entry.getKey()).addDefaultResforExec(exec);
          node.consumeResourcesforTask(exec,topologies.getById(entry.getKey()));
        }
      }
    }
  }
 else {
    for (    RAS_Node n : nodeIdToNode.values()) {
      n.setAvailableMemory(n.getAvailableMemoryResources());
    }
  }
}
