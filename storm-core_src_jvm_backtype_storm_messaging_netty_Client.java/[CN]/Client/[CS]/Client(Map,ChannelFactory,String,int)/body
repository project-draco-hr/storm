{
  this.factory=factory;
  channelRef=new AtomicReference<Channel>(null);
  closing=false;
  pendings=new AtomicLong(0);
  flushCheckTimer=new AtomicLong(Long.MAX_VALUE);
  buffer_size=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_BUFFER_SIZE));
  max_retries=Math.min(30,Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_MAX_RETRIES)));
  base_sleep_ms=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_MIN_SLEEP_MS));
  max_sleep_ms=Utils.getInt(storm_conf.get(Config.STORM_MESSAGING_NETTY_MAX_SLEEP_MS));
  this.messageBatchSize=Utils.getInt(storm_conf.get(Config.STORM_NETTY_MESSAGE_BATCH_SIZE),262144);
  blocking=Utils.getBoolean(storm_conf.get(Config.STORM_NETTY_BLOCKING),false);
  flushCheckInterval=Utils.getInt(storm_conf.get(Config.STORM_NETTY_FLUSH_CHECK_INTERVAL_MS),10);
  LOG.info("New Netty Client, connect to " + host + ", "+ port+ ", config: "+ ", buffer_size: "+ buffer_size);
  bootstrap=new ClientBootstrap(factory);
  bootstrap.setOption("tcpNoDelay",true);
  bootstrap.setOption("sendBufferSize",buffer_size);
  bootstrap.setOption("keepAlive",true);
  bootstrap.setPipelineFactory(new StormClientPipelineFactory(this));
  remote_addr=new InetSocketAddress(host,port);
  Thread flushChecker=new Thread(new Runnable(){
    @Override public void run(){
      connect();
      while (!closing) {
        long flushCheckTime=flushCheckTimer.get();
        long now=System.currentTimeMillis();
        if (now > flushCheckTime) {
          Channel channel=channelRef.get();
          if (null != channel && channel.isWritable()) {
            flush();
          }
        }
        try {
          Thread.sleep(flushCheckInterval);
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
,name() + "-flush-checker");
  flushChecker.setDaemon(true);
  flushChecker.start();
}
