{
  meterExecuteCalls.mark();
  LOG.debug("Received DRPC request for {} {} at {} ",functionName,funcArgs,System.currentTimeMillis());
  Map<String,String> map=new HashMap<>();
  map.put(DRPCAuthorizerBase.FUNCTION_NAME,functionName);
  checkAuthorization(authorizer,map,"execute");
  int idinc=this.ctr.incrementAndGet();
  int maxvalue=1000000000;
  int newid=idinc % maxvalue;
  if (idinc != newid) {
    this.ctr.compareAndSet(idinc,newid);
  }
  String strid=String.valueOf(newid);
  Semaphore sem=new Semaphore(0);
  DRPCRequest req=new DRPCRequest(funcArgs,strid);
  this.idtoStart.put(strid,Time.currentTimeSecs());
  this.idtoSem.put(strid,sem);
  this.idtoFunction.put(strid,functionName);
  this.idtoRequest.put(strid,req);
  ConcurrentLinkedQueue<DRPCRequest> queue=acquireQueue(functionName);
  queue.add(req);
  LOG.debug("Waiting for DRPC request for {} {} at {}",functionName,funcArgs,System.currentTimeMillis());
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
    LOG.error("acquire fail ",e);
  }
  LOG.debug("Acquired for DRPC request for {} {} at {}",functionName,funcArgs,System.currentTimeMillis());
  Object result=this.idtoResult.get(strid);
  LOG.info("Returning for DRPC request for " + functionName + " "+ funcArgs+ " at "+ (System.currentTimeMillis()));
  this.cleanup(strid);
  if (result instanceof DRPCExecutionException) {
    throw (DRPCExecutionException)result;
  }
  if (result == null) {
    throw new DRPCExecutionException("Request timed out");
  }
  return String.valueOf(result);
}
