{
  User topologySubmitter=this.userMap.get(td.getTopologySubmitter());
  if (cluster.getUnassignedExecutors(td).size() > 0) {
    LOG.info("/********Scheduling topology {} from User {}************/",td.getName(),topologySubmitter);
    LOG.info("{}",this.userMap.get(td.getTopologySubmitter()).getDetailedInfo());
    LOG.info("{}",User.getResourcePoolAverageUtilizationForUsers(this.userMap.values()));
    LOG.info("Nodes:\n{}",this.nodes);
    LOG.debug("From cluster:\n{}",ResourceUtils.printScheduling(this.cluster,this.topologies));
    LOG.debug("From Nodes:\n{}",ResourceUtils.printScheduling(this.nodes));
    SchedulingState schedulingState=this.checkpointSchedulingState();
    while (true) {
      ResourceAwareStrategy RAStrategy=new ResourceAwareStrategy(this.cluster,this.topologies);
      SchedulingResult result=RAStrategy.schedule(td);
      LOG.info("scheduling result: {}",result);
      if (result.isValid()) {
        if (result.isSuccess()) {
          try {
            if (mkAssignment(td,result.getSchedulingResultMap())) {
              topologySubmitter.moveTopoFromPendingToRunning(td,this.cluster);
            }
 else {
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            }
          }
 catch (          IllegalStateException ex) {
            LOG.error(ex.toString());
            LOG.error("Unsuccessful in scheduling: IllegalStateException thrown!",td.getId());
            this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
          }
          break;
        }
 else {
          if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {
            if (!this.makeSpaceForTopo(td)) {
              this.cluster.setStatus(td.getId(),result.getErrorMessage());
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td);
              break;
            }
            continue;
          }
 else           if (result.getStatus() == SchedulingStatus.FAIL_INVALID_TOPOLOGY) {
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
            break;
          }
 else {
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            break;
          }
        }
      }
 else {
        LOG.warn("Scheduling results returned from topology {} is not vaild! Topology with be ignored.",td.getName());
        this.restoreCheckpointSchedulingState(schedulingState);
        topologySubmitter=this.userMap.get(td.getTopologySubmitter());
        topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
        break;
      }
    }
  }
 else {
    LOG.warn("Topology {} is already fully scheduled!",td.getName());
    topologySubmitter.moveTopoFromPendingToRunning(td,this.cluster);
    throw new IllegalStateException("illegal");
  }
}
