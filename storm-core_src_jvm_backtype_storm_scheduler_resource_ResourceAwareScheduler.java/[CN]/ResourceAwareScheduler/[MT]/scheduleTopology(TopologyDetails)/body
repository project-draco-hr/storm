{
  ResourceAwareStrategy RAStrategy=new ResourceAwareStrategy(this.cluster,this.topologies);
  User topologySubmitter=this.userMap.get(td.getTopologySubmitter());
  if (cluster.getUnassignedExecutors(td).size() > 0) {
    LOG.info("/********Scheduling topology {} from User {}************/",td.getName(),topologySubmitter);
    LOG.info("{}",this.userMap.get(td.getTopologySubmitter()).getDetailedInfo());
    LOG.info("{}",User.getResourcePoolAverageUtilizationForUsers(this.userMap.values()));
    Map<String,SchedulerAssignment> assignmentCheckpoint=this.cluster.getAssignments();
    while (true) {
      SchedulingResult result=RAStrategy.schedule(td);
      LOG.info("scheduling result: {}",result);
      if (result.isValid()) {
        if (result.isSuccess()) {
          try {
            if (mkAssignment(td,result.getSchedulingResultMap())) {
              topologySubmitter.moveTopoFromPendingToRunning(td,this.cluster);
            }
 else {
              resetAssignments(assignmentCheckpoint);
              topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            }
          }
 catch (          IllegalStateException ex) {
            LOG.error(ex.toString());
            LOG.error("Unsuccessful in scheduling",td.getId());
            this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
            resetAssignments(assignmentCheckpoint);
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
          }
          break;
        }
 else {
          if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {
            if (!this.makeSpaceForTopo(td)) {
              topologySubmitter.moveTopoFromPendingToAttempted(td);
              this.cluster.setStatus(td.getId(),result.getErrorMessage());
              resetAssignments(assignmentCheckpoint);
              break;
            }
            continue;
          }
 else           if (result.getStatus() == SchedulingStatus.FAIL_INVALID_TOPOLOGY) {
            topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
            resetAssignments(assignmentCheckpoint);
            break;
          }
 else {
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            resetAssignments(assignmentCheckpoint);
            break;
          }
        }
      }
 else {
        LOG.warn("Scheduling results returned from topology {} is not vaild! Topology with be ignored.",td.getName());
        topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
        resetAssignments(assignmentCheckpoint);
        break;
      }
    }
  }
 else {
    LOG.warn("Topology {} is already fully scheduled!",td.getName());
    topologySubmitter.moveTopoFromPendingToRunning(td,this.cluster);
    throw new IllegalStateException("illegal");
  }
}
