{
  User topologySubmitter=this.userMap.get(td.getTopologySubmitter());
  if (cluster.getUnassignedExecutors(td).size() > 0) {
    LOG.debug("/********Scheduling topology {} from User {}************/",td.getName(),topologySubmitter);
    SchedulingState schedulingState=this.checkpointSchedulingState();
    IStrategy rasStrategy=null;
    try {
      rasStrategy=(IStrategy)Utils.newInstance((String)td.getConf().get(Config.TOPOLOGY_SCHEDULER_STRATEGY));
    }
 catch (    RuntimeException e) {
      LOG.error("failed to create instance of IStrategy: {} with error: {}! Topology {} will not be scheduled.",td.getName(),td.getConf().get(Config.TOPOLOGY_SCHEDULER_STRATEGY),e.getMessage());
      this.restoreCheckpointSchedulingState(schedulingState);
      topologySubmitter=this.userMap.get(td.getTopologySubmitter());
      topologySubmitter.moveTopoFromPendingToInvalid(td);
      this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling - failed to create instance of topology strategy " + td.getConf().get(Config.TOPOLOGY_SCHEDULER_STRATEGY) + ". Please check logs for details");
      return;
    }
    IEvictionStrategy evictionStrategy=null;
    while (true) {
      SchedulingResult result=null;
      try {
        rasStrategy.prepare(this.topologies,this.cluster,this.userMap,this.nodes);
        result=rasStrategy.schedule(td);
      }
 catch (      Exception e) {
        LOG.error("Exception thrown when running strategy {} to schedule topology {}. Topology will not be scheduled! Error: {} StackTrace: {}",rasStrategy.getClass().getName(),td.getName(),e.getMessage(),Arrays.toString(e.getStackTrace()));
        this.restoreCheckpointSchedulingState(schedulingState);
        topologySubmitter=this.userMap.get(td.getTopologySubmitter());
        topologySubmitter.moveTopoFromPendingToInvalid(td);
        this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling - Exception thrown when running strategy {}" + rasStrategy.getClass().getName() + ". Please check logs for details");
      }
      LOG.debug("scheduling result: {}",result);
      if (result != null && result.isValid()) {
        if (result.isSuccess()) {
          try {
            if (mkAssignment(td,result.getSchedulingResultMap())) {
              topologySubmitter.moveTopoFromPendingToRunning(td);
              this.cluster.setStatus(td.getId(),"Running - " + result.getMessage());
            }
 else {
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td);
              this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling - Unable to assign executors to nodes. Please check logs for details");
            }
          }
 catch (          IllegalStateException ex) {
            LOG.error(ex.toString());
            LOG.error("Unsuccessful in scheduling - IllegalStateException thrown when attempting to assign executors to nodes. Error: {} StackTrace: {}",ex.getClass().getName(),Arrays.toString(ex.getStackTrace()));
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToAttempted(td);
            this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling - IllegalStateException thrown when attempting to assign executors to nodes. Please check log for details.");
          }
          break;
        }
 else {
          if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {
            if (evictionStrategy == null) {
              try {
                evictionStrategy=(IEvictionStrategy)Utils.newInstance((String)this.conf.get(Config.RESOURCE_AWARE_SCHEDULER_EVICTION_STRATEGY));
              }
 catch (              RuntimeException e) {
                LOG.error("failed to create instance of eviction strategy: {} with error: {}! No topology eviction will be done.",this.conf.get(Config.RESOURCE_AWARE_SCHEDULER_EVICTION_STRATEGY),e.getMessage());
                topologySubmitter.moveTopoFromPendingToAttempted(td);
                break;
              }
            }
            boolean madeSpace=false;
            try {
              evictionStrategy.prepare(this.topologies,this.cluster,this.userMap,this.nodes);
              madeSpace=evictionStrategy.makeSpaceForTopo(td);
            }
 catch (            Exception e) {
              LOG.error("Exception thrown when running eviction strategy {} to schedule topology {}. No evictions will be done! Error: {} StackTrace: {}",evictionStrategy.getClass().getName(),td.getName(),e.getClass().getName(),Arrays.toString(e.getStackTrace()));
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td);
              break;
            }
            if (!madeSpace) {
              LOG.debug("Could not make space for topo {} will move to attempted",td);
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td);
              this.cluster.setStatus(td.getId(),"Not enough resources to schedule - " + result.getErrorMessage());
              break;
            }
            continue;
          }
 else           if (result.getStatus() == SchedulingStatus.FAIL_INVALID_TOPOLOGY) {
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
            break;
          }
 else {
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            break;
          }
        }
      }
 else {
        LOG.warn("Scheduling results returned from topology {} is not vaild! Topology with be ignored.",td.getName());
        this.restoreCheckpointSchedulingState(schedulingState);
        topologySubmitter=this.userMap.get(td.getTopologySubmitter());
        topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
        break;
      }
    }
  }
 else {
    LOG.warn("Topology {} is already fully scheduled!",td.getName());
    topologySubmitter.moveTopoFromPendingToRunning(td);
    if (this.cluster.getStatusMap().get(td.getId()) == null || this.cluster.getStatusMap().get(td.getId()).equals("")) {
      this.cluster.setStatus(td.getId(),"Fully Scheduled");
    }
  }
}
