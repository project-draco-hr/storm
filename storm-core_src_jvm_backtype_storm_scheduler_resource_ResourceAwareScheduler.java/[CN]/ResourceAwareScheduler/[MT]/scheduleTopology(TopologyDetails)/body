{
  ResourceAwareStrategy RAStrategy=new ResourceAwareStrategy(this.cluster,this.topologies);
  if (cluster.needsScheduling(td) && cluster.getUnassignedExecutors(td).size() > 0) {
    LOG.info("/********Scheduling topology {} from User {}************/",td.getName(),td.getTopologySubmitter());
    LOG.info("{}",this.userMap.get(td.getTopologySubmitter()).getDetailedInfo());
    LOG.info("{}",User.getResourcePoolAverageUtilizationForUsers(this.userMap.values()));
    Map<WorkerSlot,Collection<ExecutorDetails>> schedulerAssignmentMap=RAStrategy.schedule(td);
    double requestedMemOnHeap=td.getTotalRequestedMemOnHeap();
    double requestedMemOffHeap=td.getTotalRequestedMemOffHeap();
    double requestedCpu=td.getTotalRequestedCpu();
    double assignedMemOnHeap=0.0;
    double assignedMemOffHeap=0.0;
    double assignedCpu=0.0;
    if (schedulerAssignmentMap != null) {
      try {
        Set<String> nodesUsed=new HashSet<String>();
        int assignedWorkers=schedulerAssignmentMap.keySet().size();
        for (        Map.Entry<WorkerSlot,Collection<ExecutorDetails>> workerToTasksEntry : schedulerAssignmentMap.entrySet()) {
          WorkerSlot targetSlot=workerToTasksEntry.getKey();
          Collection<ExecutorDetails> execsNeedScheduling=workerToTasksEntry.getValue();
          RAS_Node targetNode=RAStrategy.idToNode(targetSlot.getNodeId());
          targetNode.assign(targetSlot,td,execsNeedScheduling,this.cluster);
          LOG.debug("ASSIGNMENT    TOPOLOGY: {}  TASKS: {} To Node: {} on Slot: {}",td.getName(),execsNeedScheduling,targetNode.getHostname(),targetSlot.getPort());
          if (!nodesUsed.contains(targetNode.getId())) {
            nodesUsed.add(targetNode.getId());
          }
          assignedMemOnHeap+=targetSlot.getAllocatedMemOnHeap();
          assignedMemOffHeap+=targetSlot.getAllocatedMemOffHeap();
          assignedCpu+=targetSlot.getAllocatedCpu();
        }
        LOG.debug("Topology: {} assigned to {} nodes on {} workers",td.getId(),nodesUsed.size(),assignedWorkers);
        this.cluster.setStatus(td.getId(),"Fully Scheduled");
        this.getUser(td.getTopologySubmitter()).moveTopoFromPendingToRunning(td);
        LOG.info("getNextUser: {}",this.getNextUser());
      }
 catch (      IllegalStateException ex) {
        LOG.error(ex.toString());
        LOG.error("Unsuccessful in scheduling",td.getId());
        this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
        this.getUser(td.getTopologySubmitter()).moveTopoFromPendingToAttempted(td);
      }
    }
 else {
      LOG.error("Unsuccessful in scheduling {}",td.getId());
      this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
      this.getUser(td.getTopologySubmitter()).moveTopoFromPendingToAttempted(td);
    }
    Double[] resources={requestedMemOnHeap,requestedMemOffHeap,requestedCpu,assignedMemOnHeap,assignedMemOffHeap,assignedCpu};
    LOG.debug("setResources for {}: requested on-heap mem, off-heap mem, cpu: {} {} {} " + "assigned on-heap mem, off-heap mem, cpu: {} {} {}",td.getId(),requestedMemOnHeap,requestedMemOffHeap,requestedCpu,assignedMemOnHeap,assignedMemOffHeap,assignedCpu);
    this.cluster.setResources(td.getId(),resources);
  }
 else {
    LOG.warn("Topology {} already scheduled!",td.getName());
    this.cluster.setStatus(td.getId(),"Fully Scheduled");
  }
  updateSupervisorsResources(cluster,topologies);
}
