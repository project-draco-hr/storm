{
  User topologySubmitter=this.userMap.get(td.getTopologySubmitter());
  if (cluster.getUnassignedExecutors(td).size() > 0) {
    LOG.info("/********Scheduling topology {} from User {}************/",td.getName(),topologySubmitter);
    LOG.info("{}",this.userMap.get(td.getTopologySubmitter()).getDetailedInfo());
    LOG.info("{}",User.getResourcePoolAverageUtilizationForUsers(this.userMap.values()));
    LOG.info("Nodes:\n{}",this.nodes);
    LOG.debug("From cluster:\n{}",ResourceUtils.printScheduling(this.cluster,this.topologies));
    LOG.debug("From Nodes:\n{}",ResourceUtils.printScheduling(this.nodes));
    SchedulingState schedulingState=this.checkpointSchedulingState();
    IStrategy RAStrategy=null;
    try {
      RAStrategy=(IStrategy)Utils.newInstance((String)td.getConf().get(Config.TOPOLOGY_SCHEDULER_STRATEGY));
    }
 catch (    RuntimeException e) {
      LOG.error("failed to create instance of IStrategy: {} with error: {}! Topology {} will not be scheduled.",td.getName(),td.getConf().get(Config.TOPOLOGY_SCHEDULER_STRATEGY),e.getMessage());
      topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
      return;
    }
    IEvictionStrategy evictionStrategy=null;
    while (true) {
      RAStrategy.prepare(this.topologies,this.cluster,this.userMap,this.nodes);
      SchedulingResult result=RAStrategy.schedule(td);
      LOG.info("scheduling result: {}",result);
      if (result.isValid()) {
        if (result.isSuccess()) {
          try {
            if (mkAssignment(td,result.getSchedulingResultMap())) {
              topologySubmitter.moveTopoFromPendingToRunning(td,this.cluster);
            }
 else {
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            }
          }
 catch (          IllegalStateException ex) {
            LOG.error(ex.toString());
            LOG.error("Unsuccessful in scheduling: IllegalStateException thrown!",td.getId());
            this.cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
          }
          break;
        }
 else {
          if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {
            if (evictionStrategy == null) {
              try {
                evictionStrategy=(IEvictionStrategy)Utils.newInstance((String)this.conf.get(Config.RESOURCE_AWARE_SCHEDULER_EVICTION_STRATEGY));
              }
 catch (              RuntimeException e) {
                LOG.error("failed to create instance of eviction strategy: {} with error: {}! No topology eviction will be done.",this.conf.get(Config.RESOURCE_AWARE_SCHEDULER_EVICTION_STRATEGY),e.getMessage());
                topologySubmitter.moveTopoFromPendingToAttempted(td);
                break;
              }
            }
            evictionStrategy.prepare(this.topologies,this.cluster,this.userMap,this.nodes);
            if (!evictionStrategy.makeSpaceForTopo(td)) {
              this.cluster.setStatus(td.getId(),result.getErrorMessage());
              this.restoreCheckpointSchedulingState(schedulingState);
              topologySubmitter=this.userMap.get(td.getTopologySubmitter());
              topologySubmitter.moveTopoFromPendingToAttempted(td);
              break;
            }
            continue;
          }
 else           if (result.getStatus() == SchedulingStatus.FAIL_INVALID_TOPOLOGY) {
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
            break;
          }
 else {
            this.restoreCheckpointSchedulingState(schedulingState);
            topologySubmitter=this.userMap.get(td.getTopologySubmitter());
            topologySubmitter.moveTopoFromPendingToAttempted(td,this.cluster);
            break;
          }
        }
      }
 else {
        LOG.warn("Scheduling results returned from topology {} is not vaild! Topology with be ignored.",td.getName());
        this.restoreCheckpointSchedulingState(schedulingState);
        topologySubmitter=this.userMap.get(td.getTopologySubmitter());
        topologySubmitter.moveTopoFromPendingToInvalid(td,this.cluster);
        break;
      }
    }
  }
 else {
    LOG.warn("Topology {} is already fully scheduled!",td.getName());
    topologySubmitter.moveTopoFromPendingToRunning(td,this.cluster);
    throw new IllegalStateException("illegal");
  }
}
