{
  LOG.debug("\n\n\nRerunning ResourceAwareScheduler...");
  ResourceAwareStrategy RAStrategy=new ResourceAwareStrategy(cluster,topologies);
  LOG.debug(printScheduling(cluster,topologies));
  for (  TopologyDetails td : topologies.getTopologies()) {
    String topId=td.getId();
    Map<WorkerSlot,Collection<ExecutorDetails>> schedulerAssignmentMap;
    if (cluster.needsScheduling(td) && cluster.getUnassignedExecutors(td).size() > 0) {
      LOG.debug("/********Scheduling topology {} ************/",topId);
      schedulerAssignmentMap=RAStrategy.schedule(td);
      double requestedMemOnHeap=td.getTotalRequestedMemOnHeap();
      double requestedMemOffHeap=td.getTotalRequestedMemOffHeap();
      double requestedCpu=td.getTotalRequestedCpu();
      double assignedMemOnHeap=0.0;
      double assignedMemOffHeap=0.0;
      double assignedCpu=0.0;
      if (schedulerAssignmentMap != null) {
        try {
          Set<String> nodesUsed=new HashSet<String>();
          int assignedWorkers=schedulerAssignmentMap.keySet().size();
          for (          Map.Entry<WorkerSlot,Collection<ExecutorDetails>> workerToTasksEntry : schedulerAssignmentMap.entrySet()) {
            WorkerSlot targetSlot=workerToTasksEntry.getKey();
            Collection<ExecutorDetails> execsNeedScheduling=workerToTasksEntry.getValue();
            RAS_Node targetNode=RAStrategy.idToNode(targetSlot.getNodeId());
            targetNode.assign(targetSlot,td,execsNeedScheduling,cluster);
            LOG.debug("ASSIGNMENT    TOPOLOGY: {}  TASKS: {} To Node: {} on Slot: {}",td.getName(),execsNeedScheduling,targetNode.getHostname(),targetSlot.getPort());
            if (!nodesUsed.contains(targetNode.getId())) {
              nodesUsed.add(targetNode.getId());
            }
            assignedMemOnHeap+=targetSlot.getAllocatedMemOnHeap();
            assignedMemOffHeap+=targetSlot.getAllocatedMemOffHeap();
            assignedCpu+=targetSlot.getAllocatedCpu();
          }
          LOG.debug("Topology: {} assigned to {} nodes on {} workers",td.getId(),nodesUsed.size(),assignedWorkers);
          cluster.setStatus(td.getId(),"Fully Scheduled");
        }
 catch (        IllegalStateException ex) {
          LOG.error(ex.toString());
          LOG.error("Unsuccessful in scheduling",td.getId());
          cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
        }
      }
 else {
        LOG.error("Unsuccessful in scheduling",td.getId());
        cluster.setStatus(td.getId(),"Unsuccessful in scheduling");
      }
      Double[] resources={requestedMemOnHeap,requestedMemOffHeap,requestedCpu,assignedMemOnHeap,assignedMemOffHeap,assignedCpu};
      LOG.debug("setResources for {}: requested on-heap mem, off-heap mem, cpu: {} {} {} " + "assigned on-heap mem, off-heap mem, cpu: {} {} {}",td.getId(),requestedMemOnHeap,requestedMemOffHeap,requestedCpu,assignedMemOnHeap,assignedMemOffHeap,assignedCpu);
      cluster.setResources(td.getId(),resources);
    }
 else {
      cluster.setStatus(td.getId(),"Fully Scheduled");
    }
  }
}
