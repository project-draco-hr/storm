{
  Connection connection=null;
  try {
    connection=this.dataSource.getConnection();
    boolean autoCommit=connection.getAutoCommit();
    if (autoCommit) {
      connection.setAutoCommit(false);
    }
    StringBuilder sb=new StringBuilder();
    sb.append("Insert into ").append(tableName).append(" (");
    Collection<String> columnNames=Collections2.transform(columnLists.get(0),new Function<Column,String>(){
      @Override public String apply(      Column input){
        return input.getColumnName();
      }
    }
);
    String columns=Joiner.on(",").join(columnNames);
    sb.append(columns).append(") values ( ");
    String placeHolders=StringUtils.chop(StringUtils.repeat("?,",columnNames.size()));
    sb.append(placeHolders).append(")");
    String query=sb.toString();
    LOG.debug("Executing query {}",query);
    PreparedStatement preparedStatement=connection.prepareStatement(query);
    preparedStatement.setQueryTimeout(queryTimeoutSecs);
    for (    List<Column> columnList : columnLists) {
      setPreparedStatementParams(preparedStatement,columnList);
      preparedStatement.addBatch();
    }
    int[] results=preparedStatement.executeBatch();
    if (Arrays.asList(results).contains(Statement.EXECUTE_FAILED)) {
      connection.rollback();
      throw new RuntimeException("failed at least one sql statement in the batch, operation rolled back.");
    }
 else {
      try {
        connection.commit();
      }
 catch (      SQLException e) {
        throw new RuntimeException("Failed to commit inserts in table " + tableName,e);
      }
    }
  }
 catch (  SQLException e) {
    throw new RuntimeException("Failed to insert in table " + tableName,e);
  }
 finally {
    closeConnection(connection);
  }
}
