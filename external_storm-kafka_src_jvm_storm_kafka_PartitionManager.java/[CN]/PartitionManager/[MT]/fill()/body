{
  long start=System.nanoTime();
  long offset;
  final boolean had_failed=!failed.isEmpty();
  if (had_failed) {
    offset=failed.first();
  }
 else {
    offset=_emittedToOffset;
  }
  ByteBufferMessageSet msgs=null;
  try {
    msgs=KafkaUtils.fetchMessages(_spoutConfig,_consumer,_partition,offset);
  }
 catch (  UpdateOffsetException e) {
    _emittedToOffset=KafkaUtils.getOffset(_consumer,_spoutConfig.topic,_partition.partition,_spoutConfig);
    LOG.warn("Using new offset: {}",_emittedToOffset);
    return;
  }
  long end=System.nanoTime();
  long millis=(end - start) / 1000000;
  _fetchAPILatencyMax.update(millis);
  _fetchAPILatencyMean.update(millis);
  _fetchAPICallCount.incr();
  if (msgs != null) {
    int numMessages=0;
    for (    MessageAndOffset msg : msgs) {
      final Long cur_offset=msg.offset();
      if (cur_offset < offset) {
        continue;
      }
      if (!had_failed || failed.contains(cur_offset)) {
        numMessages+=1;
        _pending.add(cur_offset);
        _waitingToEmit.add(new MessageAndRealOffset(msg.message(),cur_offset));
        _emittedToOffset=Math.max(msg.nextOffset(),_emittedToOffset);
        if (had_failed) {
          failed.remove(cur_offset);
        }
      }
    }
    _fetchAPIMessageCount.incrBy(numMessages);
  }
}
