{
  this._queueName=PREFIX + queueName;
  WaitStrategy wait=null;
  if (timeout <= 0) {
    wait=new LiteBlockingWaitStrategy();
  }
 else {
    wait=new TimeoutBlockingWaitStrategy(timeout,TimeUnit.MILLISECONDS);
  }
  _buffer=RingBuffer.create(type,new ObjectEventFactory(),size,wait);
  _consumer=new Sequence();
  _barrier=_buffer.newBarrier();
  _buffer.addGatingSequences(_consumer);
  _metrics=new QueueMetrics();
  if (type == ProducerType.SINGLE) {
    consumerStartedFlag=true;
  }
 else {
    try {
      publishDirect(FLUSH_CACHE,true);
    }
 catch (    InsufficientCapacityException e) {
      throw new RuntimeException("This code should be unreachable!",e);
    }
  }
}
